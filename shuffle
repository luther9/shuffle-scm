#!/usr/bin/env guile
!#

;; 2017 Luther Thompson. This program is public domain. See COPYING for details.

(use-modules ((ice-9 receive) #:select (receive)))
(use-modules ((ice-9 rdelim) #:select (read-line)))

;; 'add-to-load-path' doesn't belong in this file when it's installed, but it's
;; the only way to test the module.
(add-to-load-path ".")
(use-modules ((flag) #:select (get-flags option-ref)))

;; A pile of cards is represented by a list of integers. The head represents the
;; top of the pile.

;;; Return a shuffled list.
(define* (shuffled-list max random-state
			#:optional (current 0) (v (make-vector max)))
  (if (>= current max)
      (vector->list v)
      (let* ((next (1+ current))
	     (i (random next random-state)))
	(vector-set! v current (vector-ref v i))
	(vector-set! v i current)
	(shuffled-list max random-state next v))))

;;; Inserts an item into the list in ascending order.
(define (insort lst x limit)
  (if (and (positive? limit) (> x (car lst)))
      (cons (car lst) (insort (cdr lst) x (1- limit)))
      (cons x lst)))

;;; Choose some elements to add to a list in sorted order.
;;; identical: Number of elements to add.
;;; pool: The list to select random numbers from.
;;; tail: The end of the new list.
;;; limit: The length of the sorted part of tail.
(define (add-clump identical pool tail limit)
  (if (positive? identical)
      (add-clump (1- identical) (cdr pool) (insort tail (car pool) limit)
		 (1+ limit))
      (cons pool tail)))

;;; Add some semi-sorted elements to a list.
;;; identicals: A list of integers. Each number is the length of a sorted
;;; sub-list of the return value.
;;; pool: The list to select random numbers from.
;;; random-state: RNG.
(define (add-identicals identicals pool tail)
  (if (null? identicals)
      tail
      (let ((clump-result (add-clump (car identicals) pool tail 0)))
	(add-identicals (cdr identicals) (car clump-result)
			(cdr clump-result)))))

;;; Return a list of cards mapped to their future position.
;;; uniques: The number of unique cards.
;;; identicals: A list of numbers of identical or pre-shuffled cards.
;;; pool: A list of positions that aren't taken yet.
;;; tail: The end of the new list.
(define (deck uniques identicals pool tail)
  (if (positive? uniques)
      (deck (1- uniques) identicals (cdr pool) (cons (car pool) tail))
      (add-identicals identicals pool tail)))

; #t means pile A. #f means pile B.
(define (get-new-pile card median)
  (> card median))

(define (get-transfer pile new-pile median n)
  (if (and (not (null? pile)) (eq? new-pile (get-new-pile (car pile) median)))
      (get-transfer (cdr pile) new-pile median (1+ n))
      n))

;; Splits a pile into two piles.
(define (split pile median pile-a pile-b output input)
  (if (null? pile)
      (list pile-a pile-b)
      (let* ((new-pile (get-new-pile (car pile) median))
	     ;; Number of cards to transfer.
	     (transfer-n (get-transfer pile new-pile median 0))
	     ;; The actual cards to transfer.
	     (transfer (list-head pile transfer-n))
	     ;; The pile in hand after the transfer.
	     (next-pile (list-tail pile transfer-n)))
	(format output "~A to ~A" transfer-n
		(if new-pile
		    "A"
		    "B"))
	(read-line input)
	(if new-pile
	    (split next-pile median (append transfer pile-a) pile-b output
		   input)
	    (split next-pile median pile-a (append transfer pile-b) output
		   input)))))

;;; Return #t iff the pile is shuffled.
(define (shuffled? lst)
  (sorted? lst <))

;;; Return #t if there is a second element which is one more than the first.
;;; lst: A list that must have at least one element.
(define (in-streak? lst)
  (let ((rest (cdr lst)))
    (and (not (null? rest)) (= (1+ (car lst)) (car rest)))))

;;; Return two values: 1st is the number at the beginning of the median streak.
;;; 2nd is the list that begins with median-int.
;;; start: The first number of the current streak.
;;; current-node: The list to search for median-int.
;;; median-int: The number that must be within the middle chunk.
(define (get-middle-chunk start current-node median-int)
  (let ((rest (cdr current-node)))
    (if (= (car current-node) median-int)
	(values start current-node)
	(get-middle-chunk (if (in-streak? current-node) start (car rest))
			  rest median-int))))

;;; Get the last value in the first streak of lst.
(define (streak-end lst)
  (if (in-streak? lst)
      (streak-end (cdr lst))
      (car lst)))

;;; Get the highest number that will go to pile B.
(define (get-cutoff pile)
  (let ((median (+ (apply min pile) (/ (1- (length pile)) 2))))
    (receive (start median-list)
	     (get-middle-chunk (car pile) pile (truncate median))
	     (let ((end (streak-end median-list)))
	       (if (< (- median start) (- end median))
		   (1- start)
		   end)))))

;;; Shuffle the deck. Argument is a list containing the deck to shuffle.
(define (shuffle piles output input)
  (unless (null? piles)
	  ;; The current pile.
	  (let ((hand (car piles))
		;; All piles after the current one.
		(rest (cdr piles)))
	    (if (shuffled? hand)
		(begin
		  (format output "Pile of ~A cards is already shuffled.\n"
			  (length hand))
		  (shuffle rest output input))
		(begin
		  (format output "~A\n" (map length piles))
		  (shuffle (append (split hand (get-cutoff hand) '() '() output
					  input)
				   rest)
			   output input))))))

(define options
  (get-flags (command-line) `((seed (value #t) (predicate ,string->number)))))
(define args (map string->number (option-ref options '() #f)))
(define seed (option-ref options 'seed #f))
(shuffle `(,(deck (car args) (cdr args)
		  (shuffled-list (apply + args)
				 (if seed
				     (seed->random-state seed)
				     (random-state-from-platform)))
		  '()))
	 (current-output-port) (current-input-port))

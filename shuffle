#!/usr/bin/env guile
!#

;; 2017 Luther Thompson. This program is public domain. See COPYING for details.

(use-modules (ice-9 getopt-long))
(use-modules (ice-9 rdelim))

;; A pile of cards is represented by a list of integers. The head represents the
;; top of the pile.

;; Returns the list lst with a random element moved to the head.
(define (pop-random lst random-state)
  (let ((i (random (length lst) random-state)))
    (cons (list-ref lst i) (append (list-head lst i) (list-tail lst (1+ i))))))

;;; Inserts an item into the list in ascending order.
(define (insort lst x limit)
  (if (and (positive? limit) (> x (car lst)))
      (cons (car lst) (insort (cdr lst) x (1- limit)))
      (cons x lst)))

;;; Choose some elements to add to a list in sorted order.
;;; identical: Number of elements to add.
;;; pool: The list to select random numbers from.
;;; random-state: The RNG.
;;; tail: The end of the new list.
;;; limit: The length of the sorted part of tail.
(define (add-clump identical pool random-state tail limit)
  (if (positive? identical)
      (let ((new-pool (pop-random pool random-state)))
	(add-clump (1- identical) (cdr new-pool) random-state
		   (insort tail (car new-pool) limit) (1+ limit)))
      (cons pool tail)))

;;; Add some semi-sorted elements to a list.
;;; identicals: A list of integers. Each number is the length of a sorted
;;; sub-list of the return value.
;;; pool: The list to select random numbers from.
;;; random-state: RNG.
(define (add-identicals identicals pool random-state tail)
  (if (null? identicals)
      tail
      (let ((clump-result
	     (add-clump (car identicals) pool random-state tail 0)))
	(add-identicals (cdr identicals) (car clump-result) random-state
			(cdr clump-result)))))

;;; Return a list of cards mapped to their future position.
;;; uniques: The number of unique cards.
;;; identicals: A list of numbers of identical or pre-shuffled cards.
;;; pool: A list of positions that aren't taken yet.
;;; random-state: The RNG.
;;; tail: The end of the new list.
(define (deck uniques identicals pool random-state tail)
  (if (positive? uniques)
      (let ((new-pool (pop-random pool random-state)))
	(deck (1- uniques) identicals (cdr new-pool) random-state
	      (cons (car new-pool) tail)))
      (add-identicals identicals pool random-state tail)))

; #t means pile A. #f means pile B.
(define (get-new-pile card median)
  (> card median))

(define (get-transfer pile new-pile median n)
  (if (and (not (null? pile)) (eq? new-pile (get-new-pile (car pile) median)))
      (get-transfer (cdr pile) new-pile median (1+ n))
      n))

;; Splits a pile into two piles.
(define (split pile median pile-a pile-b output input)
  (if (null? pile)
      (list pile-a pile-b)
      (let* ((new-pile (get-new-pile (car pile) median))
	     ;; Number of cards to transfer.
	     (transfer-n (get-transfer pile new-pile median 0))
	     ;; The actual cards to transfer.
	     (transfer (list-head pile transfer-n))
	     ;; The pile in hand after the transfer.
	     (next-pile (list-tail pile transfer-n)))
	(format output "~A to ~A" transfer-n
		(if new-pile
		    "A"
		    "B"))
	(read-line input)
	(if new-pile
	    (split next-pile median (append transfer pile-a) pile-b output
		   input)
	    (split next-pile median pile-a (append transfer pile-b) output
		   input)))))

;;; Return #t iff the pile is shuffled.
(define (shuffled? lst)
  (sorted? lst <))

;;; Shuffle the deck. Argument is a list containing the deck to shuffle.
(define (shuffle piles output input)
  (unless (null? piles)
	  ;; The current pile.
	  (let ((hand (car piles))
		;; All piles after the current one.
		(rest (cdr piles)))
	    (if (shuffled? hand)
		(begin
		  (format output "Pile of ~A cards is already shuffled.\n"
			  (length hand))
		  (shuffle rest output input))
		(begin
		  (format output "~A\n" (map length piles))
		  (shuffle (append (split hand
					  (quotient (+ (apply max hand)
						       (apply min hand))
						    2)
					  '() '() output input)
				   rest)
			   output input))))))

(define options
  (getopt-long (command-line)
	       `((seed (value #t) (predicate ,string->number)
		       (single-char #\s)))))
(define args (map string->number (option-ref options '() #f)))
(define seed (option-ref options 'seed #f))
(shuffle `(,(deck (car args) (cdr args) (iota (apply + args))
		  (if seed
		      (seed->random-state seed)
		      (random-state-from-platform))
		  '()))
	 (current-output-port) (current-input-port))

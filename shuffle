#!/usr/bin/env guile
!#

;;; Copyright 2017-2018 Luther Thompson

;;; This program is free software: you can redistribute it and/or modify
;;; it under the terms of the GNU General Public License (GPL3) as published by
;;; the Free Software Foundation, either version 3 of the License, or
;;; (at your option) any later version.

;;; You have the following additional permission: You may convey the program in
;;; object code form under the terms of sections 4 and 5 of GPL3 without being
;;; bound by section 6 of GPL3.

;;; This program is distributed in the hope that it will be useful,
;;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;;; GNU General Public License for more details.

;;; You should have received a copy of the GNU General Public License
;;; along with this program.  If not, see <https://www.gnu.org/licenses/>.

;; 'add-to-load-path' doesn't belong in this file when it's installed, but it's
;; the only way to test the flag module.
(add-to-load-path ".")
(use-modules ((ice-9 rdelim) #:select (read-line))
	     ((ice-9 receive) #:select (receive))
	     ((srfi srfi-1)
	      #:select (car+cdr find fold fold-right reduce-right))
	     ((oop goops)
	      #:select (define-class define-method make <list> <real>))

	     ((flag) #:select (get-flags option-ref)))

(define-syntax-rule (unpack-pair formal1 formal2 expr body ...)
  (receive (formal1 formal2) (car+cdr expr) body ...))

(define (shuffled? streaks)
  "Return #t if STREAKS has only one streak. Return #f if it has more."
  (null? (cdr streaks)))

;;; A streak represents a group of consecutive integers. Streaks are important
;;; because they represent sequences in a card pile which will not be split
;;; apart.
(define-class <streak> ()
  (min #:init-keyword #:min #:getter min)
  (size #:init-keyword #:size #:init-value 1 #:getter size))

(define-method (size (streaks <list>))
  "Return the sum of all lengths in STREAKS."
  (apply + (map size streaks)))

(define-method (min (pile <list>))
  "Return the lowest represented card in PILE."
  (apply min (map min pile)))

;;; #t means pile A. #f means pile B.
(define (get-new-pile streak median)
  (let ((lo (min streak)))
    (< (- median lo) (- (+ lo (size streak)) median))))

;;; Return 3 values:
;;; 1. The remaining hand after the transfer.
;;; 2. A boolean indicating the new pile. #t means pile A.
;;; 3. A list of streaks to append to the new pile.
(define* (get-transfer hand median
		       #:optional
		       (next (get-new-pile (car hand) median)) (transfer '()))
  (if (or (null? hand) (not (eq? next (get-new-pile (car hand) median))))
      (values hand next (reverse transfer))
      (get-transfer (cdr hand) median next (cons (car hand) transfer))))

(define-method (end (s <streak>))
  "Return the end of the range represented by S."
  (+ (min s) (size s)))

(define-method (top streaks)
  "Return the min of the top streak of S. S must not be empty."
  (min (car streaks)))

(define-method (new-streak (min <real>) (size <real>))
  (make <streak> #:min min #:size size))

(define-method (push (s <streak>) (streaks <list>))
  "Return a new streak list with S added to the top."
  (if (or (null? streaks) (not (= (end s) (top streaks))))
      (cons s streaks)
      (cons (new-streak (min s) (+ (size s) (size (car streaks))))
	    (cdr streaks))))

(define-method (new-streak (min <real>))
  (make <streak> #:min min))

(define-method (push (n <real>) (streaks <list>))
  "Return a new streak list with N added to the top."
  (push (new-streak n) streaks))

(define (append-streaks . lists)
  "Works like append, but all arguments must be lists of either streaks or
numbers. Normalize the result."
  (fold-right (lambda (streaks previous) (fold-right push previous streaks))
	      '() lists))

;;; Split a pile into two piles.
(define* (split hand
		#:optional
		(median (+ (min hand) (/ (size hand) 2)))
		(pile-a '()) (pile-b '()))
  (if (null? hand)
      (list pile-a pile-b)
      (receive (hand* next-pile transfer) (get-transfer hand median)
	(let ((transfer-size (size transfer))
	      (next-letter (if next-pile "A" "B"))
	      (pile-a* (if next-pile (append-streaks transfer pile-a) pile-a))
	      (pile-b* (if next-pile pile-b (append-streaks transfer pile-b))))
	  (format #t "~A to ~A" transfer-size next-letter)
	  (read-line)
	  (split hand* median pile-a* pile-b*)))))

;;; Shuffle the deck. Argument is a list containing the deck to shuffle.
(define (shuffle piles)
  (unless (null? piles)
    (unpack-pair hand rest piles
      (if (shuffled? hand)
	  (begin
	    (format #t "Pile of ~A cards is already shuffled.\n" (size hand))
	    (shuffle rest))
	  (begin
	    (format #t "~A\n" (map size piles))
	    (shuffle (append (split hand) rest)))))))

(define (join-joinable-streak identicals main-streaks)
  "Return the (possibly modified) arguments as a pair. If a streak in IDENTICALS
can be joined with the top streak of MAIN-STREAKS, do so and remove it from
IDENTICALS."
  (let ((joinable
	 (find (lambda (s) (= (end s) (top main-streaks))) identicals)))
    (if joinable
	(cons (delq joinable identicals) (cons joinable main-streaks))
	(cons identicals main-streaks))))

(define (n->streaks n pool)
  "Take N elements from POOL and make them into a StreakList. Return the
StreakList and the remaining pool."
  (cons (append-streaks (sort (list-head pool n) <)) (list-tail pool n)))

(define (groups->streaks groups pool)
  "Map GROUPS, in reverse order, into a list of streak lists, taking the actual
numbers from POOL."
  (cdr
   (fold
    (lambda (n pool+lists)
      (unpack-pair streaks pool (n->streaks n (car pool+lists))
	(cons* pool streaks (cdr pool+lists))))
    (list pool) groups)))

(define (deck groups pool)
  "Return a streak-list. POOL is a list of numbers that will go into the
streak-list in mostly the same order. GROUPS is a list of numbers that represent
partitions of identical cards which will be re-ordered to make the physical
shuffling easier."
  (reduce-right
   (lambda (identicals main-streaks)
     (unpack-pair identicals main-streaks
		  (join-joinable-streak identicals main-streaks)
       (append-streaks identicals main-streaks)))
   #f (groups->streaks groups pool)))

(define* (*iota-shuffle! max random-state #:optional (i 0) (lst '()))
  (if (>= i max)
      lst
      (let* ((next (1+ i))
	     (k (random next random-state)))
	(*iota-shuffle! max random-state next
			(append (list-head lst k) (list i)
				(list-tail lst k))))))

;;; Return a list of all integers in [0, MAX) in a random order.
(define (iota-shuffle max seed)
  (*iota-shuffle! max
		  (if seed
		      (seed->random-state seed)
		      (random-state-from-platform))))

(let* ((options
	(get-flags (command-line)
		   `((seed (value #t) (predicate ,string->number)))))
       (args (map string->number (option-ref options '() #f))))
  (if (or (null? args) (memq #f args))
      (format #t "shuffle requires at least 1 integer argument\n")
      (shuffle
       (list
	(deck (append (make-list (car args) 1) (cdr args))
	      (iota-shuffle (apply + args) (option-ref options 'seed #f)))))))

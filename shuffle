#!/usr/bin/env guile
!#

;;; 2017-2018 Luther Thompson

;;; This program is free software: you can redistribute it and/or modify
;;; it under the terms of the GNU General Public License (GPL3) as published by
;;; the Free Software Foundation, either version 3 of the License, or
;;; (at your option) any later version.

;;; You have the following additional permission: You may convey the program in
;;; object code form under the terms of sections 4 and 5 of GPL3 without being
;;; bound by section 6 of GPL3.

;;; This program is distributed in the hope that it will be useful,
;;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;;; GNU General Public License for more details.

;;; You should have received a copy of the GNU General Public License
;;; along with this program.  If not, see <https://www.gnu.org/licenses/>.

;; 'add-to-load-path' doesn't belong in this file when it's installed, but it's
;; the only way to test the flag module.
(add-to-load-path ".")
(use-modules ((ice-9 rdelim) #:select (read-line))
	     ((ice-9 receive) #:select (receive))
	     ((srfi srfi-9 gnu) #:select (define-immutable-record-type))

	     ((flag) #:select (get-flags option-ref)))

(define-syntax-rule (unpack-pair formal-0 formal-1 expr body ...)
  (let ((e expr))
    ((lambda (formal-0 formal-1) body ...) (car e) (cdr e))))

;;; A streak represents a group of consecutive integers. Streaks are important
;;; because they represent sequences in a card pile which will not be split
;;; apart.
(define-immutable-record-type <Streak>
  (Streak min size)
  streak?
  (min streak-min)
  (size streak-size))

;;; Split LST at index K into two segments and return them both as lists.
;;; Reverse the order of the head.
(define* (reverse-split lst k #:optional (head '()))
  (if (positive? k)
      (reverse-split (cdr lst) (1- k) (cons (car lst) head))
      (values head lst)))

;;; Append the elements of LST, in reverse, to OBJ.
(define (reverse-append lst obj)
  (if (null? lst)
      obj
      (reverse-append (cdr lst) (cons (car lst) obj))))

(define* (iota-shuffle*! max random-state #:optional (i 0) (lst '()))
  (if (>= i max)
      lst
      (let ((next (1+ i)))
	(receive (head tail)
		 (reverse-split lst (random next random-state))
		 (iota-shuffle*! max random-state next
				(reverse-append head (cons i tail)))))))

;;; Return a list of all integers in [0, MAX) in a random order.
(define (iota-shuffle max seed)
  (iota-shuffle*! max
		  (if seed
		      (seed->random-state seed)
		      (random-state-from-platform))))

;;; Return #t iff the pile is shuffled.
(define (pile-shuffled? p)
  (null? (cdr p)))

(define (pile-size pile)
  (apply + (map streak-size pile)))

(define (pile-min pile)
  (apply min (map streak-min pile)))

;;; #t means pile A. #f means pile B.
(define (get-new-pile streak median)
  (let ((lo (streak-min streak)))
    (< (- median lo) (- (+ lo (streak-size streak)) median))))

;;; Return 3 values:
;;; 1. The remaining hand after the transfer.
;;; 2. A boolean indicating the new pile. #t means pile A.
;;; 3. A list of streaks to append to the new pile, in reverse order.
(define* (get-transfer hand median
		       #:optional (next (get-new-pile (car hand) median))
		       (transfer '()))
  (if (or (null? hand) (not (eq? next (get-new-pile (car hand) median))))
      (values hand next transfer)
      (get-transfer (cdr hand) median next (cons (car hand) transfer))))

(define (reverse-append-streaks a b)
  (reverse-append (cdr a) (streak-cons b (car a))))

;;; Split a pile into two piles.
(define* (split hand
		#:optional (median (+ (pile-min hand) (/ (pile-size hand) 2)))
		(pile-a '()) (pile-b '()))
  (if (null? hand)
      (list pile-a pile-b)
      (receive (hand* next-pile transfer) (get-transfer hand median)
	       (let ((size (pile-size transfer))
		     (next-letter (if next-pile "A" "B"))
		     (pile-a*
		      (if next-pile (reverse-append-streaks transfer pile-a)
			  pile-a))
		     (pile-b*
		      (if next-pile pile-b
			  (reverse-append-streaks transfer pile-b))))
		 (format #t "~A to ~A" size next-letter)
		 (read-line)
		 (split hand* median pile-a* pile-b*)))))

;;; Shuffle the deck. Argument is a list containing the deck to shuffle.
(define (shuffle piles)
  (unless (null? piles)
	  ;; The current pile.
	  (let ((hand (car piles))
		;; All piles after the current one.
		(rest (cdr piles)))
	    (if (pile-shuffled? hand)
		(begin
		  (format #t "Pile of ~A cards is already shuffled.\n"
			  (pile-size hand))
		  (shuffle rest))
		(begin
		  (format #t "~A\n" (map pile-size piles))
		  (shuffle (append (split hand) rest)))))))

(define (append-streaks* reversed streaks)
  (if (null? reversed)
      streaks
      (append-streaks* (cdr reversed)
		       (apply streak-cons streaks (car reversed)))))

;;; Append lists of streaks.
(define (append-streaks . streaks)
  (if (null? streaks)
      '()
      (let ((reversed (reverse streaks)))
	(append-streaks* (cdr reversed) (car reversed)))))

;;; Return a list of streaks.
;;; identicals: A list of numbers of identical or pre-shuffled cards.
;;; pool: A list of numbers to draw from.
;;; deck: A pre-existing list of streaks to append to.
(define (get-chunks identicals pool deck)
  (if (null? identicals)
      deck
      (receive (chunk pool*) (reverse-split pool (car identicals))
	       (get-chunks (cdr identicals) pool*
			   (append-streaks (list->streaks (sort chunk <))
					   deck)))))

(define (streak-cons* streaks reversed)
  (if (null? reversed)
      streaks
      (let* ((s (car reversed))
	     (min (streak-min s))
	     (size (streak-size s))
	     (rest (cdr reversed)))
	(if
	 (or (null? streaks)
	     (not
	      (= (+ (streak-min s) (streak-size s))
		 (streak-min (car streaks)))))
	 (streak-cons* (cons s streaks) rest)
	 (streak-cons*
	  (cons (Streak min (+ size (streak-size (car streaks)))) (cdr streaks))
	  rest)))))

;;; Add any number of streaks S, to a list of STREAKS.
(define (streak-cons streaks . s)
  (streak-cons* streaks (reverse s)))

;;; Return a streak of size 1.
(define (n->streak n)
  (Streak n 1))

;;; Consolodate a list of numbers into streaks. STREAKS is a list of streaks to
;;; append to.
(define* (list->streaks lst #:optional (streaks '()))
  (apply streak-cons streaks (map n->streak lst)))

(let ((options
       (get-flags (command-line)
		  `((seed (value #t) (predicate ,string->number))))))
  (unpack-pair unique identicals
	       (map string->number (option-ref options '() #f))
	       (let ((size (apply + unique identicals)))
		 (receive (deck pool)
			  (reverse-split
			   (iota-shuffle size (option-ref options 'seed #f))
			   unique)
			  (shuffle
			   `(,(get-chunks identicals pool
					  (list->streaks deck))))))))

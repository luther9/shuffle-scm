#!/usr/bin/env guile
!#

;;; Copyright 2017-2018 Luther Thompson

;;; This program is free software: you can redistribute it and/or modify
;;; it under the terms of the GNU General Public License (GPL3) as published by
;;; the Free Software Foundation, either version 3 of the License, or
;;; (at your option) any later version.

;;; You have the following additional permission: You may convey the program in
;;; object code form under the terms of sections 4 and 5 of GPL3 without being
;;; bound by section 6 of GPL3.

;;; This program is distributed in the hope that it will be useful,
;;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;;; GNU General Public License for more details.

;;; You should have received a copy of the GNU General Public License
;;; along with this program.  If not, see <https://www.gnu.org/licenses/>.

;; 'add-to-load-path' doesn't belong in this file when it's installed, but it's
;; the only way to test the flag module.
(add-to-load-path ".")
(use-modules ((ice-9 rdelim) #:select (read-line))
	     ((ice-9 receive) #:select (receive))
	     ((srfi srfi-1)
	      #:select (car+cdr find fold fold-right reduce-right))
	     ((oop goops)
	      #:select
	      (define-class define-generic define-method is-a? make <applicable>
	       <null> <pair> <procedure> <real>))

	     ((flag) #:select (get-flags option-ref)))

(define-syntax-rule (unpack-pair formal1 formal2 expr body ...)
  (receive (formal1 formal2) (car+cdr expr) body ...))

;;; Apparently, these are invalid generics unless we declare them.
(define-generic append)
(define-generic car)
(define-generic cdr)
(define-generic find)
(define-generic fold-right)
(define-generic null?)

(define-class <streak-list> ()
  (data #:init-keyword #:data #:getter data))

(define-method (shuffled? (s <streak-list>))
  "Return #t if S has only one streak. Return #f if S has more."
  (null? (cdr (data s))))

;;; A streak represents a group of consecutive integers. Streaks are important
;;; because they represent sequences in a card pile which will not be split
;;; apart.
(define-class <streak> ()
  (min #:init-keyword #:min #:getter min)
  (size #:init-keyword #:size #:init-value 1 #:getter size))

(define-method (size (s <streak-list>))
  "Return the sum of all lengths in S."
  (apply + (map size (data s))))

(define-method (min (pile <streak-list>))
  "Return the lowest represented card in S."
  (apply min (map min (data pile))))

(define-method (null? (s <streak-list>))
  "#t if S is empty, #f otherwise."
  (null? (data s)))

;;; #t means pile A. #f means pile B.
(define (get-new-pile streak median)
  (let ((lo (min streak)))
    (< (- median lo) (- (+ lo (size streak)) median))))

(define-method (car (s <streak-list>))
  "Return first streak of S."
  (car (data s)))

(define-method (fold-right (proc <applicable>) init (lst <streak-list>))
  "Like the standard fold-right, but LST is a streak list instead of a regular
list."
  (fold-right proc init (data lst)))

(define-method (end (s <streak>))
  "Return the end of the range represented by S."
  (+ (min s) (size s)))

(define-method (top (s <streak-list>))
  "Return the min of the top streak of S. S must not be empty."
  (min (car (data s))))

(define-method (Streak (min <real>) (size <real>))
  (make <streak> #:min min #:size size))

(define null-streak-list (make <streak-list> #:data '()))

(define-method (StreakList (data <pair>))
  ;; Cheat by only checking the first element. I hope all lists are homogeneous.
  (let ((first (car data)))
    (cond ((real? first) (append null-streak-list data))
	  ((is-a? first <streak>) (make <streak-list> #:data data))
	  (#t (error "data must be a list of either streaks or reals.")))))

(define-method (Streak (min <real>))
  (make <streak> #:min min))

(define-method (push (s <streak>) (streaks <streak-list>))
  "Return a new streak-list with S added to the top."
  (let ((lst (data streaks)))
    (if (or (null? lst) (not (= (end s) (top streaks))))
	(StreakList (cons s lst))
	(StreakList
	 (cons (Streak (min s) (+ (size s) (size (car lst)))) (cdr lst))))))

(define-method (*append lst (streaks <streak-list>))
  "Append a streak-list or a list of numbers to STREAKS."
  (fold-right push streaks lst))

(define-method (append (streaks <streak-list>) . lst)
  "Append streak-lists or lists of numbers to STREAKS. This is different from
the standard append in that the tail object is given as the first argument, not
the last."
  (fold-right *append streaks lst))

(define-method (push (n <real>) (streaks <streak-list>))
  "Return a new streak-list with N added to the top."
  (push (Streak n) streaks))

(define-method (cdr (s <streak-list>))
  "Return a copy of S with the top streak removed."
  (StreakList (cdr (data s))))

(define-method (StreakList (data <null>))
  null-streak-list)

;;; Return 3 values:
;;; 1. The remaining hand after the transfer.
;;; 2. A boolean indicating the new pile. #t means pile A.
;;; 3. A list of streaks to append to the new pile, in reverse order.
(define* (get-transfer hand median
		       #:optional (next (get-new-pile (car hand) median))
		       (transfer '()))
  (if (or (null? hand) (not (eq? next (get-new-pile (car hand) median))))
      (values hand next (StreakList (reverse transfer)))
      (get-transfer (cdr hand) median next (cons (car hand) transfer))))

;;; Split a pile into two piles.
(define* (split hand
		#:optional
		(median (+ (min hand) (/ (size hand) 2)))
		(pile-a '()) (pile-b '()))
  (if (null? hand)
      (list pile-a pile-b)
      (receive (hand* next-pile transfer) (get-transfer hand median)
	(let ((transfer-size (size transfer))
	      (next-letter (if next-pile "A" "B"))
	      (pile-a* (if next-pile (append transfer pile-a) pile-a))
	      (pile-b* (if next-pile pile-b (append transfer pile-b))))
	  (format #t "~A to ~A" transfer-size next-letter)
	  (read-line)
	  (split hand* median pile-a* pile-b*)))))

;;; Shuffle the deck. Argument is a list containing the deck to shuffle.
(define (shuffle piles)
  (unless (null? piles)
    (unpack-pair hand rest piles
      (if (shuffled? hand)
	  (begin
	    (format #t "Pile of ~A cards is already shuffled.\n" (size hand))
	    (shuffle rest))
	  (begin
	    (format #t "~A\n" (map size piles))
	    (shuffle (append (split hand) rest)))))))

(define-method (find (proc <procedure>) (s <streak-list>))
  "Apply the core find to the data of streak-list S."
  (find proc (data s)))

(define (join-joinable-streak identicals main-streaks)
  "Return the (possibly modified) arguments as a pair. If a streak in IDENTICALS
can be joined with the top streak of MAIN-STREAKS, do so and remove it from
IDENTICALS."
  (let ((joinable
	 (find (lambda (s) (= (end s) (top main-streaks))) identicals)))
    (if joinable
	(cons (delq joinable identicals) (cons joinable main-streaks))
	(cons identicals main-streaks))))

(define (n->streaks n pool)
  "Take N elements from POOL and make them into a StreakList. Return the
StreakList and the remaining pool."
  (cons (StreakList (sort (list-head pool n) <)) (list-tail pool n)))

(define (groups->streaks groups pool)
  "Map GROUPS into a list of streak lists, taking the actual numbers from POOL."
  (cdr
   (fold-right
    (lambda (n pool+lists)
      (unpack-pair streaks pool (n->streaks n (car pool+lists))
	(cons* pool streaks (cdr pool+lists))))
    (list pool) groups)))

(define (deck groups pool)
  "Return a streak-list. POOL is a list of numbers that will go into the
streak-list in mostly the same order. GROUPS is a list of numbers that represent
partitions of identical cards which will be re-ordered to make the physical
shuffling easier."
  (reduce-right
   (lambda (identicals main-streaks)
     (unpack-pair identicals main-streaks
		  (join-joinable-streak identicals main-streaks)
       (append main-streaks identicals)))
   #f (groups->streaks groups pool)))

(define* (*iota-shuffle! max random-state #:optional (i 0) (lst '()))
  (if (>= i max)
      lst
      (let* ((next (1+ i))
	     (k (random next random-state)))
	(*iota-shuffle! max random-state next
			(append (list-head lst k) (list i)
				(list-tail lst k))))))

;;; Return a list of all integers in [0, MAX) in a random order.
(define (iota-shuffle max seed)
  (*iota-shuffle! max
		  (if seed
		      (seed->random-state seed)
		      (random-state-from-platform))))

(let* ((options
	(get-flags (command-line)
		   `((seed (value #t) (predicate ,string->number)))))
       (args (map string->number (option-ref options '() #f))))
  (if (or (null? args) (memq #f args))
      (format #t "shuffle requires at least 1 integer argument\n")
      (shuffle
       (list
	(deck (append (make-list (car args) 1) (cdr args))
	      (iota-shuffle (apply + args) (option-ref options 'seed #f)))))))

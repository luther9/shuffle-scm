#!/usr/bin/env guile
!#

;;; 2017-2018 Luther Thompson.
;;; This program is public domain. See COPYING for details.

;; 'add-to-load-path' doesn't belong in this file when it's installed, but it's
;; the only way to test the flag module.
(add-to-load-path ".")
(use-modules ((ice-9 rdelim) #:select (read-line))
	     ((ice-9 receive) #:select (receive))

	     ((flag) #:select (get-flags option-ref)))

;;; A pile of cards is represented by a list of integers. The head represents
;;; the top of the pile.

(define-syntax-rule (unpack-pair formal-0 formal-1 expr body ...)
  (let ((e expr))
    ((lambda (formal-0 formal-1) body ...) (car e) (cdr e))))

;;; Split LST into two segments at index K and return them both as lists.
;;; Preserve the order of the tail.
(define* (unordered-head-tail lst k #:optional (head '()))
  (if (positive? k)
      (unordered-head-tail (cdr lst) (1- k) (cons (car lst) head))
      (values head lst)))

;;; Return a list with all elements of LST with OBJ as the last cdr.
(define (unordered-append lst obj)
  (if (null? lst)
      obj
      (unordered-append (cdr lst) (cons (car lst) obj))))

(define* (iota-shuffle*! max random-state #:optional (i 0) (lst '()))
  (if (>= i max)
      lst
      (let ((next (1+ i)))
	(receive (head tail)
		 (unordered-head-tail lst (random next random-state))
		 (iota-shuffle*! max random-state next
				(unordered-append head (cons i tail)))))))

;;; Return a list of all integers in [0, MAX) in a random order.
(define (iota-shuffle max seed)
  (iota-shuffle*! max
		  (if seed
		      (seed->random-state seed)
		      (random-state-from-platform))))

;;; Return #t iff the pile is shuffled.
(define (shuffled? lst)
  (sorted? lst <))

;;; Return #t if there is a second element which is one more than the first.
;;; lst: A list that must have at least one element.
(define (in-streak? lst)
  (let ((rest (cdr lst)))
    (and (not (null? rest)) (= (1+ (car lst)) (car rest)))))

;;; Return two values: 1st is the number at the beginning of the median streak.
;;; 2nd is the list that begins with median-int.
;;; start: The first number of the current streak.
;;; current-node: The list to search for median-int.
;;; median-int: The number that must be within the middle chunk.
(define (get-middle-chunk start current-node median-int)
  (let ((rest (cdr current-node)))
    (if (= (car current-node) median-int)
	(values start current-node)
	(get-middle-chunk (if (in-streak? current-node) start (car rest))
			  rest median-int))))

;;; Get the last value in the first streak of lst.
(define (streak-end lst)
  (if (in-streak? lst)
      (streak-end (cdr lst))
      (car lst)))

;;; Get the highest number that will go to pile B.
(define (get-cutoff pile)
  (let ((median (+ (apply min pile) (/ (1- (length pile)) 2))))
    (receive (start median-list)
	     (get-middle-chunk (car pile) pile (truncate median))
	     (let ((end (streak-end median-list)))
	       (if (< (- median start) (- end median))
		   (1- start)
		   end)))))

;; #t means pile A. #f means pile B.
(define (get-new-pile card median)
  (> card median))

(define (get-transfer pile new-pile median n)
  (if (and (not (null? pile)) (eq? new-pile (get-new-pile (car pile) median)))
      (get-transfer (cdr pile) new-pile median (1+ n))
      n))

;; Splits a pile into two piles.
(define* (split pile
		#:optional (median (get-cutoff pile)) (pile-a '()) (pile-b '()))
  (if (null? pile)
      (list pile-a pile-b)
      (let* ((new-pile (get-new-pile (car pile) median))
	     ;; Number of cards to transfer.
	     (transfer-n (get-transfer pile new-pile median 0))
	     ;; The actual cards to transfer.
	     (transfer (list-head pile transfer-n))
	     ;; The pile in hand after the transfer.
	     (next-pile (list-tail pile transfer-n)))
	(format #t "~A to ~A" transfer-n
		(if new-pile
		    "A"
		    "B"))
	(read-line)
	(if new-pile
	    (split next-pile median (append transfer pile-a) pile-b)
	    (split next-pile median pile-a (append transfer pile-b))))))

;;; Shuffle the deck. Argument is a list containing the deck to shuffle.
(define (shuffle piles)
  (unless (null? piles)
	  ;; The current pile.
	  (let ((hand (car piles))
		;; All piles after the current one.
		(rest (cdr piles)))
	    (if (shuffled? hand)
		(begin
		  (format #t "Pile of ~A cards is already shuffled.\n"
			  (length hand))
		  (shuffle rest))
		(begin
		  (format #t "~A\n" (map length piles))
		  (shuffle (append (split hand) rest)))))))

;;; Return a list of lists of sorted numbers.
;;; identicals: A list of numbers of identical or pre-shuffled cards.
;;; pool: A list of numbers to draw from.
;;; lst: The last cdr of the return value.
(define (get-chunks identicals pool lst)
  (if (null? identicals)
      lst
      (receive (chunk pool*) (unordered-head-tail pool (car identicals))
	       (get-chunks (cdr identicals) pool* (cons (sort chunk <) lst)))))

(let
    ((options
      (get-flags (command-line)
		 `((seed (value #t) (predicate ,string->number))))))
  (unpack-pair unique identicals
	       (map string->number (option-ref options '() #f))
	       (receive (deck pool)
			(unordered-head-tail
			 (iota-shuffle (apply + unique identicals)
				       (option-ref options 'seed #f))
			 unique)
			(shuffle
			 `(,(apply append
				   (get-chunks identicals pool `(,deck))))))))

